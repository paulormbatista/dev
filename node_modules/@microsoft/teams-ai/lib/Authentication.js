"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Authentication = void 0;
const botbuilder_1 = require("botbuilder");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const TurnStateProperty_1 = require("./TurnStateProperty");
/**
 * Authentication service.
 */
class Authentication {
    /**
     * Creates a new instance of the `Authentication` class.
     * @param app Application for adding routes.
     * @param settings Authentication settings.
     */
    constructor(app, settings) {
        // Create OAuthPrompt
        this._oauthPrompt = new botbuilder_dialogs_1.OAuthPrompt('OAuthPrompt', settings);
        // Add application routes to handle OAuth callbacks
        app.addRoute((context) => Promise.resolve(context.activity.type === botbuilder_1.ActivityTypes.Event && context.activity.name === botbuilder_1.tokenResponseEventName), (context, state) => __awaiter(this, void 0, void 0, function* () {
            const userDialogStatePropertyName = this.getUserDialogStatePropertyName(context);
            yield this.runDialog(context, state, userDialogStatePropertyName);
        }), false);
        app.addRoute((context) => Promise.resolve(context.activity.type === botbuilder_1.ActivityTypes.Invoke && context.activity.name === botbuilder_1.verifyStateOperationName), (context, state) => __awaiter(this, void 0, void 0, function* () {
            const userDialogStatePropertyName = this.getUserDialogStatePropertyName(context);
            yield this.runDialog(context, state, userDialogStatePropertyName);
            yield context.sendActivity({
                value: { status: 200 },
                type: botbuilder_1.ActivityTypes.InvokeResponse
            });
        }), true);
        app.addRoute((context) => Promise.resolve(context.activity.type === botbuilder_1.ActivityTypes.Invoke && context.activity.name === botbuilder_1.tokenExchangeOperationName), (context, state) => __awaiter(this, void 0, void 0, function* () {
            const userDialogStatePropertyName = this.getUserDialogStatePropertyName(context);
            yield this.runDialog(context, state, userDialogStatePropertyName);
            yield context.sendActivity({
                value: { status: 200 },
                type: botbuilder_1.ActivityTypes.InvokeResponse
            });
        }), true);
    }
    /**
     * Signs in a user.
     * @remarks
     * This method will be called automatically by the Application class.
     * @param context Current turn context.
     * @param state Application state.
     * @returns The authentication token or undefined if the user is still login in.
     */
    signInUser(context, state) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Get property names to use
            const userAuthStatePropertyName = this.getUserAuthStatePropertyName(context);
            const userDialogStatePropertyName = this.getUserDialogStatePropertyName(context);
            // Save message if not signed in
            if (!state.conversation.value[userAuthStatePropertyName]) {
                state.conversation.value[userAuthStatePropertyName] = { signedIn: false, message: context.activity.text };
            }
            const results = yield this.runDialog(context, state, userDialogStatePropertyName);
            if (results.status === botbuilder_dialogs_1.DialogTurnStatus.complete) {
                // Get user auth state
                const userAuthState = state.conversation.value[userAuthStatePropertyName];
                if (!userAuthState.signedIn && userAuthState.message) {
                    // Restore user message
                    context.activity.text = userAuthState.message;
                    userAuthState.signedIn = true;
                    delete userAuthState.message;
                    state.conversation.value[userAuthStatePropertyName] = userAuthState;
                }
                // Delete persisted dialog state
                delete state.conversation.value[userDialogStatePropertyName];
                // Return token
                return (_a = results.result) === null || _a === void 0 ? void 0 : _a.token;
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * Signs out a user.
     * @param context Current turn context.
     */
    signOutUser(context, state) {
        // Delete user auth state
        const userAuthStatePropertyName = this.getUserAuthStatePropertyName(context);
        if (state.conversation.value[userAuthStatePropertyName]) {
            delete state.conversation.value[userAuthStatePropertyName];
        }
        // Delete user dialog state
        const userDialogStatePropertyName = this.getUserDialogStatePropertyName(context);
        if (state.conversation.value[userDialogStatePropertyName]) {
            delete state.conversation.value[userDialogStatePropertyName];
        }
        return this._oauthPrompt.signOutUser(context);
    }
    /**
     * @private
     */
    getUserAuthStatePropertyName(context) {
        return `__${context.activity.from.id}:AuthState__`;
    }
    /**
     * @private
     */
    getUserDialogStatePropertyName(context) {
        return `__${context.activity.from.id}:DialogState__`;
    }
    /**
     * @private
     */
    runDialog(context, state, dialogStateProperty) {
        return __awaiter(this, void 0, void 0, function* () {
            // Save the
            const accessor = new TurnStateProperty_1.TurnStateProperty(state, 'conversation', dialogStateProperty);
            const dialogSet = new botbuilder_dialogs_1.DialogSet(accessor);
            dialogSet.add(this._oauthPrompt);
            const dialogContext = yield dialogSet.createContext(context);
            let results = yield dialogContext.continueDialog();
            if (results.status === botbuilder_dialogs_1.DialogTurnStatus.empty) {
                results = yield dialogContext.beginDialog(this._oauthPrompt.id);
            }
            return results;
        });
    }
}
exports.Authentication = Authentication;
//# sourceMappingURL=Authentication.js.map