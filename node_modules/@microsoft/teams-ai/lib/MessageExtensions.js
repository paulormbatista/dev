"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageExtensions = void 0;
const botbuilder_1 = require("botbuilder");
/**
 * @private
 */
const ANONYMOUS_QUERY_LINK_INVOKE_NAME = `composeExtension/anonymousQueryLink`;
/**
 * @private
 */
const FETCH_TASK_INVOKE_NAME = `composeExtension/fetchTask`;
/**
 * @private
 */
const QUERY_INVOKE_NAME = `composeExtension/query`;
/**
 * @private
 */
const QUERY_LINK_INVOKE_NAME = `composeExtension/queryLink`;
/**
 * @private
 */
const SELECT_ITEM_INVOKE_NAME = `composeExtension/selectItem`;
/**
 * @private
 */
const SUBMIT_ACTION_INVOKE_NAME = `composeExtension/submitAction`;
/**
 * MessageExtensions class to enable fluent style registration of handlers related to Message Extensions.
 * @template TState Type of the turn state object being persisted.
 */
class MessageExtensions {
    /**
     * Creates a new instance of the MessageExtensions class.
     * @param app Top level application class to register handlers with.
     */
    constructor(app) {
        this._app = app;
    }
    /**
     * Registers a handler for a command that performs anonymous link unfurling.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received. The handler should return a `MessagingExtensionResult`.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.url URL to unfurl.
     * @returns The application for chaining purposes.
     */
    anonymousQueryLink(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, ANONYMOUS_QUERY_LINK_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== ANONYMOUS_QUERY_LINK_INVOKE_NAME) {
                    throw new Error(`Unexpected MessageExtensions.anonymousQueryLink() triggered for activity type: ${(_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_e = (_d = context.activity.value) === null || _d === void 0 ? void 0 : _d.url) !== null && _e !== void 0 ? _e : '');
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    const response = {
                        composeExtension: result
                    };
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler to process the 'edit' action of a message that's being previewed by the
     * user prior to sending.
     * @remarks
     * This handler is called when the user clicks the 'Edit' button on a message that's being
     * previewed prior to insertion into the current chat. The handler should return a new
     * view that allows the user to edit the message.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.previewActivity The activity that's being previewed by the user.
     * @returns The application for chaining purposes.
     */
    botMessagePreviewEdit(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, SUBMIT_ACTION_INVOKE_NAME, 'edit');
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== SUBMIT_ACTION_INVOKE_NAME ||
                    ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.botMessagePreviewAction) !== 'edit') {
                    throw new Error(`Unexpected MessageExtensions.botMessagePreviewEdit() triggered for activity type: ${(_e = context === null || context === void 0 ? void 0 : context.activity) === null || _e === void 0 ? void 0 : _e.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_g = (_f = context.activity.value) === null || _f === void 0 ? void 0 : _f.botActivityPreview[0]) !== null && _g !== void 0 ? _g : {});
                yield this.returnSubmitActionResponse(context, result);
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler to process the 'send' action of a message that's being previewed by the
     * user prior to sending.
     * @remarks
     * This handler is called when the user clicks the 'Send' button on a message that's being
     * previewed prior to insertion into the current chat. The handler should complete the flow
     * by sending the message to the current chat.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.previewActivity The activity that's being previewed by the user.
     * @returns The application for chaining purposes.
     */
    botMessagePreviewSend(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, SUBMIT_ACTION_INVOKE_NAME, 'send');
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== SUBMIT_ACTION_INVOKE_NAME ||
                    ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.botMessagePreviewAction) !== 'send') {
                    throw new Error(`Unexpected MessageExtensions.botMessagePreviewSend() triggered for activity type: ${(_e = context === null || context === void 0 ? void 0 : context.activity) === null || _e === void 0 ? void 0 : _e.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                yield handler(context, state, (_g = (_f = context.activity.value) === null || _f === void 0 ? void 0 : _f.botActivityPreview[0]) !== null && _g !== void 0 ? _g : {});
                // Queue up invoke response
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    yield context.sendActivity({
                        value: { body: {}, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler to process the initial fetch task for an Action based message extension.
     * @remarks
     * Handlers should response with either an initial TaskInfo object or a string containing
     * a message to display to the user.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @returns The application for chaining purposes.
     */
    fetchTask(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, FETCH_TASK_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== FETCH_TASK_INVOKE_NAME) {
                    throw new Error(`Unexpected MessageExtensions.fetchTask() triggered for activity type: ${(_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state);
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    let response;
                    if (typeof result == 'string') {
                        // Return message
                        response = {
                            task: {
                                type: 'message',
                                value: result
                            }
                        };
                    }
                    else {
                        // Return card
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler that implements a Search based Message Extension.
     * @remarks
     * This handler is called when the user submits a query to a Search based messaging extension.
     * The handler should return a MessagingExtensionResult containing the results of the query.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.query The query parameters that were sent by the client.
     * @returns The application for chaining purposes.
     */
    query(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, QUERY_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== QUERY_INVOKE_NAME) {
                    throw new Error(`Unexpected MessageExtensions.query() triggered for activity type: ${(_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type}`);
                }
                // Flatten query options
                const meQuery = (_e = (_d = context === null || context === void 0 ? void 0 : context.activity) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : {};
                const query = {
                    count: (_g = (_f = meQuery === null || meQuery === void 0 ? void 0 : meQuery.queryOptions) === null || _f === void 0 ? void 0 : _f.count) !== null && _g !== void 0 ? _g : 25,
                    skip: (_j = (_h = meQuery === null || meQuery === void 0 ? void 0 : meQuery.queryOptions) === null || _h === void 0 ? void 0 : _h.skip) !== null && _j !== void 0 ? _j : 0,
                    parameters: {}
                };
                // Flatten query parameters
                ((_k = meQuery.parameters) !== null && _k !== void 0 ? _k : []).forEach((param) => {
                    if (param.name) {
                        query.parameters[param.name] = param.value;
                    }
                });
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, query);
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    const response = {
                        composeExtension: result
                    };
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler that implements a Link Unfurling based Message Extension.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.url The URL that should be unfurled.
     * @returns The application for chaining purposes.
     */
    queryLink(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, QUERY_LINK_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== QUERY_LINK_INVOKE_NAME) {
                    throw new Error(`Unexpected MessageExtensions.queryLink() triggered for activity type: ${(_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_d = context.activity.value) === null || _d === void 0 ? void 0 : _d.url);
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    const response = {
                        composeExtension: result
                    };
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler that implements the logic to handle the tap actions for items returned
     * by a Search based message extension.
     * @remarks
     * The `composeExtension/selectItem` INVOKE activity does not contain any sort of command ID,
     * so only a single select item handler can be registered. Developers will need to include a
     * type name of some sort in the preview item they return if they need to support multiple
     * select item handlers.
     * @template TItem Optional. Type of the item being selected.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.item The item that was selected.
     * @returns The application for chaining purposes.
     */
    selectItem(handler) {
        // Define static route selector
        const selector = (context) => {
            var _a;
            return Promise.resolve(((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) == botbuilder_1.ActivityTypes.Invoke && (context === null || context === void 0 ? void 0 : context.activity.name) === SELECT_ITEM_INVOKE_NAME);
        };
        // Add route
        this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            // Call handler and then check to see if an invoke response has already been added
            const result = yield handler(context, state, (_b = (_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : {});
            if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                // Format invoke response
                const response = {
                    composeExtension: result
                };
                // Queue up invoke response
                yield context.sendActivity({
                    value: { body: response, status: 200 },
                    type: botbuilder_1.ActivityTypes.InvokeResponse
                });
            }
        }), true);
        return this._app;
    }
    /**
     * Registers a handler that implements the submit action for an Action based messaging extension.
     * @template TData Optional. Type of data being submitted.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.data The data that was submitted.
     * @returns The application for chaining purposes.
     */
    submitAction(commandId, handler) {
        (Array.isArray(commandId) ? commandId : [commandId]).forEach((cid) => {
            const selector = createTaskSelector(cid, SUBMIT_ACTION_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e;
                // Insure that we're in an invoke as expected
                if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) !== SUBMIT_ACTION_INVOKE_NAME) {
                    throw new Error(`Unexpected MessageExtensions.submitAction() triggered for activity type: ${(_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_e = (_d = context.activity.value) === null || _d === void 0 ? void 0 : _d.data) !== null && _e !== void 0 ? _e : {});
                yield this.returnSubmitActionResponse(context, result);
            }), true);
        });
        return this._app;
    }
    /**
     * @private
     */
    returnSubmitActionResponse(context, result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                // Format invoke response
                let response;
                if (typeof result == 'string') {
                    // Return message
                    response = {
                        task: {
                            type: 'message',
                            value: result
                        }
                    };
                }
                else if (typeof result == 'object') {
                    if (result.card) {
                        // Return another task module
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    else {
                        // Return card to user
                        response = {
                            composeExtension: result
                        };
                    }
                }
                else {
                    // No action taken
                    response = {
                        composeExtension: undefined
                    };
                }
                // Queue up invoke response
                yield context.sendActivity({
                    value: { body: response, status: 200 },
                    type: botbuilder_1.ActivityTypes.InvokeResponse
                });
            }
        });
    }
}
exports.MessageExtensions = MessageExtensions;
/**
 * @private
 */
function createTaskSelector(commandId, invokeName, botMessagePreviewAction) {
    if (typeof commandId == 'function') {
        // Return the passed in selector function
        return commandId;
    }
    else if (commandId instanceof RegExp) {
        // Return a function that matches the commandId using a RegExp
        return (context) => {
            var _a, _b, _c, _d;
            const isInvoke = ((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) == botbuilder_1.ActivityTypes.Invoke && ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) == invokeName;
            if (isInvoke &&
                typeof ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.commandId) == 'string' &&
                matchesPreviewAction(context.activity, botMessagePreviewAction)) {
                return Promise.resolve(commandId.test(context.activity.value.commandId));
            }
            else {
                return Promise.resolve(false);
            }
        };
    }
    else {
        // Return a function that attempts to match commandId
        return (context) => {
            var _a, _b, _c, _d;
            const isInvoke = ((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) == botbuilder_1.ActivityTypes.Invoke && ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) == invokeName;
            return Promise.resolve(isInvoke &&
                ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.commandId) === commandId &&
                matchesPreviewAction(context.activity, botMessagePreviewAction));
        };
    }
}
/**
 * @private
 */
function matchesPreviewAction(activity, botMessagePreviewAction) {
    var _a;
    if (typeof ((_a = activity === null || activity === void 0 ? void 0 : activity.value) === null || _a === void 0 ? void 0 : _a.botMessagePreviewAction) == 'string') {
        return activity.value.botMessagePreviewAction == botMessagePreviewAction;
    }
    else {
        return botMessagePreviewAction == undefined;
    }
}
//# sourceMappingURL=MessageExtensions.js.map