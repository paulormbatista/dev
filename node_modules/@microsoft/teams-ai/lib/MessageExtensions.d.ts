/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { TurnContext, TaskModuleTaskInfo, MessagingExtensionResult, Activity } from 'botbuilder';
import { Application, RouteSelector, Query } from './Application';
import { TurnState } from './TurnState';
/**
 * MessageExtensions class to enable fluent style registration of handlers related to Message Extensions.
 * @template TState Type of the turn state object being persisted.
 */
export declare class MessageExtensions<TState extends TurnState> {
    private readonly _app;
    /**
     * Creates a new instance of the MessageExtensions class.
     * @param app Top level application class to register handlers with.
     */
    constructor(app: Application<TState>);
    /**
     * Registers a handler for a command that performs anonymous link unfurling.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received. The handler should return a `MessagingExtensionResult`.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.url URL to unfurl.
     * @returns The application for chaining purposes.
     */
    anonymousQueryLink(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, url: string) => Promise<MessagingExtensionResult>): Application<TState>;
    /**
     * Registers a handler to process the 'edit' action of a message that's being previewed by the
     * user prior to sending.
     * @remarks
     * This handler is called when the user clicks the 'Edit' button on a message that's being
     * previewed prior to insertion into the current chat. The handler should return a new
     * view that allows the user to edit the message.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.previewActivity The activity that's being previewed by the user.
     * @returns The application for chaining purposes.
     */
    botMessagePreviewEdit(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, previewActivity: Partial<Activity>) => Promise<MessagingExtensionResult | TaskModuleTaskInfo | string | null | undefined>): Application<TState>;
    /**
     * Registers a handler to process the 'send' action of a message that's being previewed by the
     * user prior to sending.
     * @remarks
     * This handler is called when the user clicks the 'Send' button on a message that's being
     * previewed prior to insertion into the current chat. The handler should complete the flow
     * by sending the message to the current chat.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.previewActivity The activity that's being previewed by the user.
     * @returns The application for chaining purposes.
     */
    botMessagePreviewSend(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, previewActivity: Partial<Activity>) => Promise<void>): Application<TState>;
    /**
     * Registers a handler to process the initial fetch task for an Action based message extension.
     * @remarks
     * Handlers should response with either an initial TaskInfo object or a string containing
     * a message to display to the user.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @returns The application for chaining purposes.
     */
    fetchTask(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<TaskModuleTaskInfo | string>): Application<TState>;
    /**
     * Registers a handler that implements a Search based Message Extension.
     * @remarks
     * This handler is called when the user submits a query to a Search based messaging extension.
     * The handler should return a MessagingExtensionResult containing the results of the query.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.query The query parameters that were sent by the client.
     * @returns The application for chaining purposes.
     */
    query<TParams extends Record<string, any> = Record<string, any>>(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, query: Query<TParams>) => Promise<MessagingExtensionResult>): Application<TState>;
    /**
     * Registers a handler that implements a Link Unfurling based Message Extension.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.url The URL that should be unfurled.
     * @returns The application for chaining purposes.
     */
    queryLink(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, url: string) => Promise<MessagingExtensionResult>): Application<TState>;
    /**
     * Registers a handler that implements the logic to handle the tap actions for items returned
     * by a Search based message extension.
     * @remarks
     * The `composeExtension/selectItem` INVOKE activity does not contain any sort of command ID,
     * so only a single select item handler can be registered. Developers will need to include a
     * type name of some sort in the preview item they return if they need to support multiple
     * select item handlers.
     * @template TItem Optional. Type of the item being selected.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.item The item that was selected.
     * @returns The application for chaining purposes.
     */
    selectItem<TItem extends Record<string, any> = Record<string, any>>(handler: (context: TurnContext, state: TState, item: TItem) => Promise<MessagingExtensionResult>): Application<TState>;
    /**
     * Registers a handler that implements the submit action for an Action based messaging extension.
     * @template TData Optional. Type of data being submitted.
     * @param commandId ID of the command(s) to register the handler for.
     * @param handler Function to call when the command is received.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.data The data that was submitted.
     * @returns The application for chaining purposes.
     */
    submitAction<TData extends Record<string, any>>(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<MessagingExtensionResult | TaskModuleTaskInfo | string | null | undefined>): Application<TState>;
    /**
     * @private
     */
    private returnSubmitActionResponse;
}
//# sourceMappingURL=MessageExtensions.d.ts.map