"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AI = void 0;
const botbuilder_1 = require("botbuilder");
const ConversationHistory_1 = require("./ConversationHistory");
const DefaultModerator_1 = require("./DefaultModerator");
const ResponseParser_1 = require("./ResponseParser");
/**
 * AI System.
 * @remarks
 * The AI system is responsible for generating plans, moderating input and output, and
 * generating prompts. It can be used free standing or routed to by the Application object.
 *
 * @template TState Optional. Type of the turn state.
 */
class AI {
    /**
     * Creates a new AI system.
     * @param options The options used to configure the AI system.
     */
    constructor(options) {
        this._actions = new Map();
        this._options = Object.assign({}, options);
        // Create moderator if needed
        if (!this._options.moderator) {
            this._options.moderator = new DefaultModerator_1.DefaultModerator();
        }
        // Initialize history options
        this._options.history = Object.assign({
            trackHistory: true,
            maxTurns: 3,
            maxTokens: 1000,
            lineSeparator: '\n',
            userPrefix: 'User:',
            assistantPrefix: 'Assistant:',
            assistantHistoryType: 'planObject'
        }, this._options.history);
        // Register default UnknownAction handler
        this.action(AI.UnknownActionName, (context, state, data, action) => {
            console.error(`An AI action named "${action}" was predicted but no handler was registered.`);
            return Promise.resolve(true);
        }, true);
        // Register default FlaggedInputAction handler
        this.action(AI.FlaggedInputActionName, (context, state, data, action) => {
            console.error(`The users input has been moderated but no handler was registered for 'AI.FlaggedInputActionName'.`);
            return Promise.resolve(true);
        }, true);
        // Register default FlaggedOutputAction handler
        this.action(AI.FlaggedOutputActionName, (context, state, data, action) => {
            console.error(`The bots output has been moderated but no handler was registered for 'AI.FlaggedOutputActionName'.`);
            return Promise.resolve(true);
        }, true);
        // Register default RateLimitedActionName
        this.action(AI.RateLimitedActionName, (context, state, data, action) => {
            throw new Error(`An AI request failed because it was rate limited`);
        }, true);
        // Register default PlanReadyActionName
        this.action(AI.PlanReadyActionName, (context, state, plan) => __awaiter(this, void 0, void 0, function* () {
            return Array.isArray(plan.commands) && plan.commands.length > 0;
        }), true);
        // Register default DoCommandActionName
        this.action(AI.DoCommandActionName, (context, state, data, action) => __awaiter(this, void 0, void 0, function* () {
            const { entities, handler } = data;
            return yield handler(context, state, entities, action);
        }), true);
        // Register default SayCommandActionName
        this.action(AI.SayCommandActionName, (context, state, data, action) => __awaiter(this, void 0, void 0, function* () {
            const response = data.response;
            const card = ResponseParser_1.ResponseParser.parseAdaptiveCard(response);
            if (card) {
                const attachment = botbuilder_1.CardFactory.adaptiveCard(card);
                const activity = botbuilder_1.MessageFactory.attachment(attachment);
                yield context.sendActivity(activity);
            }
            else if (context.activity.channelId == botbuilder_1.Channels.Msteams) {
                yield context.sendActivity(response.split('\n').join('<br>'));
            }
            else {
                yield context.sendActivity(response);
            }
            return true;
        }), true);
    }
    /**
     * Returns the moderator being used by the AI system.
     * @remarks
     * The default moderator simply allows all messages and plans through without intercepting them.
     */
    get moderator() {
        return this._options.moderator;
    }
    /**
     * Returns the configured options for the AI system.
     */
    get options() {
        return this._options;
    }
    /**
     * Returns the planner being used by the AI system.
     */
    get planner() {
        return this._options.planner;
    }
    /**
     * Returns the prompt manager being used by the AI system.
     */
    get prompts() {
        return this._options.promptManager;
    }
    /**
     * Registers a handler for a named action.
     * @remarks
     * The AI systems planner returns plans that are made up of a series of commands or actions
     * that should be performed. Registering a handler lets you provide code that should be run in
     * response to one of the predicted actions.
     *
     * Plans support a DO command which specifies the name of an action to call and an optional
     * set of entities that should be passed to the action. The internal plan executor will call
     * the registered handler for the action passing in the current context, state, and entities.
     *
     * Additionally, the AI system itself uses actions to handle things like unknown actions,
     * flagged input, and flagged output. You can override these actions by registering your own
     * handler for them. The names of the built-in actions are available as static properties on
     * the AI class.
     * @template TEntities (Optional) The type of entities that the action handler expects.
     * @param name Unique name of the action.
     * @param handler Function to call when the action is triggered.
     * @param allowOverrides Optional. If true, this handler is allowed to be overridden. Defaults to false.
     * @returns The AI system instance for chaining purposes.
     */
    action(name, handler, allowOverrides = false) {
        (Array.isArray(name) ? name : [name]).forEach((n) => {
            if (!this._actions.has(n) || allowOverrides) {
                this._actions.set(n, { handler, allowOverrides });
            }
            else {
                const entry = this._actions.get(n);
                if (entry.allowOverrides) {
                    entry.handler = handler;
                }
                else {
                    throw new Error(`The AI.action() method was called with a previously registered action named "${n}".`);
                }
            }
        });
        return this;
    }
    /**
     * Chains into another prompt and executes the plan that is returned.
     * @remarks
     * This method is used to chain into another prompt. It will call the prompt manager to
     * get the plan for the prompt and then execute the plan. The return value indicates whether
     * that plan was completely executed or not, and can be used to make decisions about whether the
     * outer plan should continue executing.
     * @param context Current turn context.
     * @param state Current turn state.
     * @param prompt Optional. Prompt name or prompt template to use. If omitted, the AI systems default prompt will be used.
     * @param options Optional. Override options for the prompt. If omitted, the AI systems configured options will be used.
     * @returns True if the plan was completely executed, otherwise false.
     */
    chain(context, state, prompt, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Configure options
            const opts = this.configureOptions(options);
            // Select prompt
            if (!prompt) {
                if (opts.prompt == undefined) {
                    throw new Error(`AI.chain() was called without a prompt and no default prompt was configured.`);
                }
                else if (typeof opts.prompt == 'function') {
                    prompt = yield opts.prompt(context, state);
                }
                else {
                    prompt = opts.prompt;
                }
            }
            // Populate {{$temp.input}}
            const temp = (_c = (_b = (_a = state) === null || _a === void 0 ? void 0 : _a.temp) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : {};
            if (typeof temp.input != 'string') {
                // Use the received activity text
                temp.input = context.activity.text;
            }
            // Populate {{$temp.history}}
            if (typeof temp.history != 'string' && opts.history.trackHistory) {
                temp.history = ConversationHistory_1.ConversationHistory.toString(state, opts.history.maxTokens, opts.history.lineSeparator);
            }
            // Render the prompt
            const renderedPrompt = yield opts.promptManager.renderPrompt(context, state, prompt);
            // Generate plan
            let plan = yield opts.moderator.reviewPrompt(context, state, renderedPrompt, opts);
            if (!plan) {
                plan = yield opts.planner.generatePlan(context, state, renderedPrompt, opts);
                plan = yield opts.moderator.reviewPlan(context, state, plan);
            }
            // Process generated plan
            let continueChain = yield this._actions.get(AI.PlanReadyActionName).handler(context, state, plan, '');
            if (continueChain) {
                // Update conversation history
                if (opts.history.trackHistory) {
                    ConversationHistory_1.ConversationHistory.addLine(state, `${opts.history.userPrefix.trim()} ${temp.input.trim()}`, opts.history.maxTurns * 2);
                    switch (opts.history.assistantHistoryType) {
                        case 'text': {
                            // Extract only the things the assistant has said
                            const text = plan.commands
                                .filter((v) => v.type == 'SAY')
                                .map((v) => v.response)
                                .join('\n');
                            ConversationHistory_1.ConversationHistory.addLine(state, `${opts.history.assistantPrefix.trim()} ${text}`, opts.history.maxTurns * 2);
                            break;
                        }
                        case 'planObject':
                        default:
                            // Embed the plan object to re-enforce the model
                            // - TODO: add support for XML as well
                            ConversationHistory_1.ConversationHistory.addLine(state, `${opts.history.assistantPrefix.trim()} ${JSON.stringify(plan)}`, opts.history.maxTurns * 2);
                            break;
                    }
                }
                // Run predicted commands
                for (let i = 0; i < plan.commands.length && continueChain; i++) {
                    // TODO
                    // eslint-disable-next-line security/detect-object-injection
                    const cmd = plan.commands[i];
                    switch (cmd.type) {
                        case 'DO': {
                            const { action } = cmd;
                            if (this._actions.has(action)) {
                                // Call action handler
                                const handler = this._actions.get(action).handler;
                                continueChain = yield this._actions
                                    .get(AI.DoCommandActionName)
                                    .handler(context, state, Object.assign({ handler }, cmd), action);
                            }
                            else {
                                // Redirect to UnknownAction handler
                                continueChain = yield this._actions
                                    .get(AI.UnknownActionName)
                                    .handler(context, state, plan, action);
                            }
                            break;
                        }
                        case 'SAY':
                            continueChain = yield this._actions
                                .get(AI.SayCommandActionName)
                                .handler(context, state, cmd, AI.SayCommandActionName);
                            break;
                        default:
                            throw new Error(`Application.run(): unknown command of '${cmd.type}' predicted.`);
                    }
                }
            }
            return continueChain;
        });
    }
    /**
     * A helper method to complete a prompt using the configured prompt manager.
     * @param context Current turn context.
     * @param state Current turn state.
     * @param prompt Prompt name or prompt template to use.
     * @param options Optional. Override options for the prompt. If omitted, the AI systems configured options will be used.
     * @returns The result of the prompt. If the prompt was not completed (typically due to rate limiting), the return value will be undefined.
     */
    completePrompt(context, state, prompt, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Configure options
            const opts = this.configureOptions(options);
            // Render the prompt
            const renderedPrompt = yield opts.promptManager.renderPrompt(context, state, prompt);
            // Complete the prompt
            return yield opts.planner.completePrompt(context, state, renderedPrompt, opts);
        });
    }
    /**
     * Creates a semantic function that can be registered with the apps prompt manager.
     * @remarks
     * Semantic functions are functions that make model calls and return their results as template
     * parameters to other prompts. For example, you could define a semantic function called
     * 'translator' that first translates the user's input to English before calling your main prompt:
     *
     * ```JavaScript
     * app.ai.prompts.addFunction('translator', app.ai.createSemanticFunction('translator-prompt'));
     * ```
     *
     * You would then create a prompt called "translator-prompt" that does the translation and then in
     * your main prompt you can call it using the template expression `{{translator}}`.
     */
    createSemanticFunction(name, template, options) {
        // Cache prompt template if being dynamically assigned
        if (template) {
            this._options.promptManager.addPromptTemplate(name, template);
        }
        return (context, state) => this.completePrompt(context, state, name, options);
    }
    /**
     * Manually executes a named action.
     * @template TEntities Optional. Type of entities expected to be passed to the action.
     * @param context Current turn context.
     * @param state Current turn state.
     * @param action Name of the action to execute.
     * @param entities Optional. Entities to pass to the action.
     * @returns True if the action thinks other actions should be executed.
     */
    doAction(context, state, action, entities) {
        if (!this._actions.has(action)) {
            throw new Error(`Can't find an action named '${action}'.`);
        }
        const handler = this._actions.get(action).handler;
        return handler(context, state, entities, action);
    }
    /**
     * @private
     */
    configureOptions(options) {
        let configuredOptions;
        if (options) {
            configuredOptions = Object.assign({}, this._options, options);
            if (options.history) {
                // Just inherit any missing history settings
                options.history = Object.assign({}, this._options.history, options.history);
            }
            else {
                // Disable history tracking by default
                options.history = Object.assign({}, this._options.history, { trackHistory: false });
            }
        }
        else {
            configuredOptions = this._options;
        }
        return configuredOptions;
    }
}
exports.AI = AI;
/**
 * An action that will be called anytime an unknown action is predicted by the planner.
 * @remarks
 * The default behavior is to simply log an error to the console. The plan is allowed to
 * continue execution by default.
 */
AI.UnknownActionName = '___UnknownAction___';
/**
 * An action that will be called anytime an input is flagged by the moderator.
 * @remarks
 * The default behavior is to simply log an error to the console. Override to send a custom
 * message to the user.
 */
AI.FlaggedInputActionName = '___FlaggedInput___';
/**
 * An action that will be called anytime an output is flagged by the moderator.
 * @remarks
 * The default behavior is to simply log an error to the console. Override to send a custom
 * message to the user.
 */
AI.FlaggedOutputActionName = '___FlaggedOutput___';
/**
 * An action that will be called anytime the planner is rate limited.
 */
AI.RateLimitedActionName = '___RateLimited___';
/**
 * An action that will be called after the plan has been predicted by the planner and it has
 * passed moderation.
 * @remarks
 * Overriding this action lets you customize the decision to execute a plan separately from the
 * moderator. The default behavior is to proceed with the plans execution only with a plan
 * contains one or more commands. Returning false from this action can be used to prevent the plan
 * from being executed.
 */
AI.PlanReadyActionName = '___PlanReady___';
/**
 * An action that is called to DO an action.
 * @remarks
 * The action system is used to do other actions. Overriding this action lets you customize the
 * execution of an individual action. You can use it to log actions being used or to prevent
 * certain actions from being executed based on policy.
 *
 * The default behavior is to simply execute the action handler passed in so you will need to
 * perform that logic yourself should you override this action.
 */
AI.DoCommandActionName = '___DO___';
/**
 * An action that is called to SAY something.
 * @remarks
 * Overriding this action lets you customize the execution of the SAY command. You can use it
 * to log the output being generated or to add support for sending certain types of output as
 * message attachments.
 *
 * The default behavior attempts to look for an Adaptive Card in the output and if found sends
 * it as an attachment. If no Adaptive Card is found then the output is sent as a plain text
 * message.
 *
 * If you override this action and want to automatically send Adaptive Cards as attachments you
 * will need to handle that yourself.
 */
AI.SayCommandActionName = '___SAY___';
//# sourceMappingURL=AI.js.map