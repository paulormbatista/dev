"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskModules = void 0;
const botbuilder_1 = require("botbuilder");
const FETCH_INVOKE_NAME = `task/fetch`;
const SUBMIT_INVOKE_NAME = `task/submit`;
const DEFAULT_TASK_DATA_FILTER = 'verb';
/**
 * TaskModules class to enable fluent style registration of handlers related to Task Modules.
 * @template TState Type of the turn state object being persisted.
 */
class TaskModules {
    /**
     * Creates a new instance of the TaskModules class.
     * @param app Top level application class to register handlers with.
     */
    constructor(app) {
        this._app = app;
    }
    /**
     * Registers a handler to process the initial fetch of the task module.
     * @remarks
     * Handlers should respond with either an initial TaskInfo object or a string containing
     * a message to display to the user.
     * @template TData Optional. Type of the data object being passed to the handler.
     * @param verb Name of the verb(s) to register the handler for.
     * @param handler Function to call when the handler is triggered.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.data Data object passed to the handler.
     * @returns The application for chaining purposes.
     */
    fetch(verb, handler) {
        (Array.isArray(verb) ? verb : [verb]).forEach((v) => {
            var _a, _b;
            const filterField = (_b = (_a = this._app.options.taskModules) === null || _a === void 0 ? void 0 : _a.taskDataFilter) !== null && _b !== void 0 ? _b : DEFAULT_TASK_DATA_FILTER;
            const selector = createTaskSelector(v, filterField, FETCH_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _c, _d, _e, _f, _g;
                // Insure that we're in an invoke as expected
                if (((_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_d = context === null || context === void 0 ? void 0 : context.activity) === null || _d === void 0 ? void 0 : _d.name) !== FETCH_INVOKE_NAME) {
                    throw new Error(`Unexpected TaskModules.fetch() triggered for activity type: ${(_e = context === null || context === void 0 ? void 0 : context.activity) === null || _e === void 0 ? void 0 : _e.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_g = (_f = context.activity.value) === null || _f === void 0 ? void 0 : _f.data) !== null && _g !== void 0 ? _g : {});
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    let response;
                    if (typeof result == 'string') {
                        // Return message
                        response = {
                            task: {
                                type: 'message',
                                value: result
                            }
                        };
                    }
                    else {
                        // Return card
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
    /**
     * Registers a handler to process the submission of a task module.
     * @remarks
     * Handlers should respond with another TaskInfo object, message string, or `null` to indicate
     * the task is completed.
     * @template TData Optional. Type of the data object being passed to the handler.
     * @param verb Name of the verb(s) to register the handler for.
     * @param handler Function to call when the handler is triggered.
     * @param handler.context Context for the current turn of conversation with the user.
     * @param handler.state Current state of the turn.
     * @param handler.data Data object passed to the handler.
     * @returns The application for chaining purposes.
     */
    submit(verb, handler) {
        (Array.isArray(verb) ? verb : [verb]).forEach((v) => {
            var _a, _b;
            const filterField = (_b = (_a = this._app.options.taskModules) === null || _a === void 0 ? void 0 : _a.taskDataFilter) !== null && _b !== void 0 ? _b : DEFAULT_TASK_DATA_FILTER;
            const selector = createTaskSelector(v, filterField, SUBMIT_INVOKE_NAME);
            this._app.addRoute(selector, (context, state) => __awaiter(this, void 0, void 0, function* () {
                var _c, _d, _e, _f, _g;
                // Insure that we're in an invoke as expected
                if (((_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.type) !== botbuilder_1.ActivityTypes.Invoke ||
                    ((_d = context === null || context === void 0 ? void 0 : context.activity) === null || _d === void 0 ? void 0 : _d.name) !== SUBMIT_INVOKE_NAME) {
                    throw new Error(`Unexpected TaskModules.submit() triggered for activity type: ${(_e = context === null || context === void 0 ? void 0 : context.activity) === null || _e === void 0 ? void 0 : _e.type}`);
                }
                // Call handler and then check to see if an invoke response has already been added
                const result = yield handler(context, state, (_g = (_f = context.activity.value) === null || _f === void 0 ? void 0 : _f.data) !== null && _g !== void 0 ? _g : {});
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    let response;
                    if (typeof result == 'string') {
                        // Return message
                        response = {
                            task: {
                                type: 'message',
                                value: result
                            }
                        };
                    }
                    else if (typeof result == 'object') {
                        // Return card
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    else {
                        response = {
                            task: undefined
                        };
                    }
                    // Queue up invoke response
                    yield context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }), true);
        });
        return this._app;
    }
}
exports.TaskModules = TaskModules;
/**
 * @private
 */
function createTaskSelector(verb, filterField, invokeName) {
    if (typeof verb == 'function') {
        // Return the passed in selector function
        return verb;
    }
    else if (verb instanceof RegExp) {
        // Return a function that matches the verb using a RegExp
        return (context) => {
            var _a, _b, _c, _d;
            const isInvoke = ((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) == botbuilder_1.ActivityTypes.Invoke && ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) == invokeName;
            if (isInvoke &&
                typeof ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.data) == 'object' &&
                typeof context.activity.value.data[filterField] == 'string') {
                return Promise.resolve(verb.test(context.activity.value.data[filterField]));
            }
            else {
                return Promise.resolve(false);
            }
        };
    }
    else {
        // Return a function that attempts to match verb
        return (context) => {
            var _a, _b, _c, _d;
            const isInvoke = ((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) == botbuilder_1.ActivityTypes.Invoke && ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) == invokeName;
            return Promise.resolve(isInvoke &&
                typeof ((_d = (_c = context === null || context === void 0 ? void 0 : context.activity) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.data) == 'object' &&
                context.activity.value.data[filterField] == verb);
        };
    }
}
//# sourceMappingURL=TaskModules.js.map